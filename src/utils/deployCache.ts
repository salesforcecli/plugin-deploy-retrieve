/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Global, TTLConfig } from '@salesforce/core';
import { Duration } from '@salesforce/kit';
import { JsonMap } from '@salesforce/ts-types';
import { DeployOptions, CachedOptions, cacheMessages } from './deploy';
import { maybeDestroyManifest } from './manifestCache';

export class DeployCache extends TTLConfig<TTLConfig.Options, CachedOptions> {
  public static getFileName(): string {
    return 'deploy-cache.json';
  }

  public static getDefaultOptions(): TTLConfig.Options {
    return {
      isGlobal: false,
      isState: true,
      filename: DeployCache.getFileName(),
      stateFolder: Global.SF_STATE_FOLDER,
      ttl: Duration.days(3),
    };
  }

  /**
   *
   * @param key jobId
   * @param value a DeployOptions object (wait is a duration, can use non-manifest options)
   * @param manifestFilePath the path to the manifest file generated by the deploy
   */
  public static async set(key: string, value: Partial<DeployOptions>): Promise<void> {
    const cache = await DeployCache.create();
    // remove properties we won't cache or that are not primitives
    const { 'metadata-dir': mdDir, 'source-dir': sourceDir, wait, ...cleanValue } = value;
    cache.set(key, { ...cleanValue, wait: wait?.minutes ?? 33, isMdapi: Boolean(mdDir) });
    await cache.write();
  }

  public static async unset(key: string): Promise<void> {
    const cache = await DeployCache.create();
    cache.unset(key);
    await Promise.all([cache.write(), maybeDestroyManifest(key)]);
  }

  public static async update(key: string, obj: JsonMap): Promise<void> {
    const cache = await DeployCache.create();
    cache.update(key, obj);
    await cache.write();
  }

  public resolveLatest(useMostRecent: boolean, key: string | undefined, throwOnNotFound = true): string {
    const keyFromLatest = useMostRecent ? this.getLatestKey() : key;
    if (!keyFromLatest) throw cacheMessages.createError('error.NoRecentJobId');

    const jobId = this.resolveLongId(keyFromLatest);

    if (throwOnNotFound && !this.has(jobId)) {
      throw cacheMessages.createError('error.InvalidJobId', [jobId]);
    }

    return jobId;
  }

  public resolveLongId(jobId: string): string {
    if (jobId.length === 18) {
      return jobId;
    } else if (jobId.length === 15) {
      const match = this.keys().find((k) => k.startsWith(jobId));
      if (match) {
        return match;
      }
      throw cacheMessages.createError('error.InvalidJobId', [jobId]);
    } else {
      throw cacheMessages.createError('error.InvalidJobId', [jobId]);
    }
  }

  public get(jobId: string): TTLConfig.Entry<CachedOptions> {
    return super.get(this.resolveLongId(jobId));
  }
}
